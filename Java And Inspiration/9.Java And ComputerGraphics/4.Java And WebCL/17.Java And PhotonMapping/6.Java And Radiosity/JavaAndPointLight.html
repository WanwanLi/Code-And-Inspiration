<!doctype html>
<html>
	<head>
		<title>Java And RayTracing</title>
		<style>
			body{ background-color:black;}
		</style>
		<script src="webcl-grid.js"></script>
		<script src="webcl-matrix.js"></script>
		<script src="webcl-object.js"></script>
		<script src="webcl-geometry.js"></script>
		<script id="webcl-kernel" type="x-kernel">
			inline float viewCoord(uint coord,uint size,float scale)
			{
				return ((coord+0.0)/(size-1.0)-0.5)*2.0*scale;
			}
			inline float3 getViewDirection(float16 viewInfo,float2 lensInfo,uint row,uint col,uint2 imageSize)
			{
				float3 eyePosition=viewInfo.s012;
				float3 viewDirection=viewInfo.s345;
				float3 upDirection=viewInfo.s678;
				float3 rightDirection=viewInfo.s9ab;
				float viewHeight=viewInfo.sc,viewWidth=viewInfo.sd;
				float viewDistance=viewInfo.se,viewFocus=viewInfo.sf;
				uint imageHeight=imageSize.s0,imageWidth=imageSize.s1;
				float upDistance=viewCoord(row,imageHeight,viewHeight);
				float rightDistance=viewCoord(col,imageWidth,viewWidth);
				float3 direction=viewDistance*viewDirection*0.5;
				direction+=upDistance*upDirection;
				direction+=rightDistance*rightDirection;
				float u=lensInfo.s0,v=lensInfo.s1;
				float3 focalPoint=eyePosition+direction*viewFocus;
				float3 lensPoint=eyePosition+u*upDirection+v*rightDirection;
				return normalize(focalPoint-lensPoint);
			}
			__constant float MaxError=0.001,MaxDistance=10000.0;
			__constant float3 objectColor=(float3)(1.0,0.0,0.0);
			inline float Abs(float x){return x>0?x:-x;}
			inline float4 intersectTriangle(float3 v0,float3 v1,float3 v2,float3 origin,float3 direction)
			{
				float4 noIntersection=(float4)(MaxDistance,0,0,0);
				float3 d=direction,p=origin;
				float3 e1=v1-v0,e2=v2-v0;
				float3 h=cross(d,e2);
				float a=dot(e1,h);
				if(Abs(a)<MaxError)return noIntersection;
				float f=1.0/a;
				float3 s=p-v0;
				float u=f*dot(s,h);
				if (u < 0.0 || u > 1.0)return noIntersection;
				float3 q=cross(s,e1);
				float v=f*dot(d,q);
				if (v < 0.0 || u + v > 1.0)return noIntersection;
				float t=f*dot(e2,q);
				if(t>MaxError)return (float4)(t,1.0-u-v,u,v);
				else return noIntersection;
			}
			float2 intersectCube(float8 cubeMinMax,float3 origin,float3 direction)
			{
				float3 cubeMin=cubeMinMax.s012;
				float3 cubeMax=cubeMinMax.s345;
				float3 tMin=(cubeMin-origin)/direction;
				float3 tMax=(cubeMax-origin)/direction;
				float2 ErrorDistance=(float2)(MaxDistance);
				float3 t1=min(tMin,tMax),t2=max(tMin,tMax);
				float tNear=max(max(t1.x,t1.y),t1.z);
				float tFar=min(min(t2.x,t2.y),t2.z);
				if(tNear>tFar)return ErrorDistance;
				else return (float2)(tNear,tFar);
			}
			inline float3 reflect(float3 L,float3 N)
			{
				return L-2.0*dot(L,N)*N;
			}
			inline float lightDecay(float lightDistance)
			{
				float lightDistance2=pow(lightDistance,2.0)+MaxError;
				return 1.0/lightDistance2;
			}
			inline float3 lightColor(float8 lightInfo,float3 position,float3 normalDirection,float3 viewDirection,float3 color)
			{
				float3 lightPosition=lightInfo.s012;
				float3 lightColor=lightInfo.s345*lightInfo.s6;
				float shininess=20.0;
				float lightDistance=length(lightPosition-position);
				float3 L=normalize(lightPosition-position);
				float3 N=normalDirection;
				float3 R=reflect(-L,N);
				float3 V=viewDirection;
				float L_N=max(dot(L,N),0.0);
				float R_V=max(dot(R,-V),0.0);
				float reflectance=0.8*pow(R_V,shininess);
				return clamp((L_N+reflectance)*color*lightColor*lightDecay(lightDistance),0.0,1.0);
			}
			inline float3 vertexCoordinate(__global float* vertices,uint index)
			{
				return (float3)(vertices[index*9+0],vertices[index*9+1],vertices[index*9+2]);
			}
			inline float3 vertexNormal(__global float* vertices,uint index)
			{
				return (float3)(vertices[index*9+3],vertices[index*9+4],vertices[index*9+5]);
			}
			inline float3 vertexColor(__global float* vertices,uint index)
			{
				return (float3)(vertices[index*9+6],vertices[index*9+7],vertices[index*9+8]);
			}
			inline float3 interpolateVector(float3 t,float3 v0,float3 v1,float3 v2)
			{
				return v0*t.s0+v1*t.s1+v2*t.s2;
			}
			inline float3 Float3(int3 x){return (float3)(x.s0,x.s1,x.s2);}
			inline int3 Int3(float3 x){return (int3)(x.s0,x.s1,x.s2);}
			inline bool between(float3 x,float3 l,float3 g)
			{
				bool b0=l.s0<=x.s0&&x.s0<=g.s0;
				bool b1=l.s1<=x.s1&&x.s1<=g.s1;
				bool b2=l.s2<=x.s2&&x.s2<=g.s2;
				return b0&&b1&&b2;
			}
			inline float3 propagateRay(float3 origin,float3 direction,float3 distance)
			{
				return origin+(distance+MaxError)*direction;
			}
			inline int3 getGridCoord(float3 position,float3 gridMin,float3 gridIntervals)
			{
				return Int3((position-gridMin)/gridIntervals);
			}
			inline bool isInGrid(float3 position,float3 gridMin,float3 gridIntervals,int3 gridCoord)
			{
				float3 minPosition=gridMin+gridIntervals*Float3(gridCoord);
				float3 maxPosition=minPosition+gridIntervals;
				return between(position,minPosition,maxPosition);
			}
			inline float isVisible(float3 normal,float3 direction)
			{
				return dot(direction,normal)<=0?1.0:0.0;
			}
			inline float16 intersectObjectInGrid(__global uint* primaryIndices,__global uint* secondaryIndices,__global uint* indices,__global float* vertices,float3 gridMin,float3 gridIntervals,int3 gridCoord,int3 gridSize,float3 origin,float3 direction)
			{
				float3 newPosition,newNormal;
				float3 v0,v1,v2,t,n0,n1,n2,c0,c1,c2;
				float3 position,normal,color=(float3)(0.0);
				float minDistance=MaxDistance,intersection=0.0;
				int j=gridCoord.s0,k=gridCoord.s1,i=gridCoord.s2;
				int column=gridSize.s0,level=gridSize.s1,row=gridSize.s2;
				uint p=primaryIndices[k*row*column+i*column+j];
				uint length=secondaryIndices[p++];
				for(i=0;i<length;i++)
				{
					uint s=secondaryIndices[p++];
					uint index0=indices[s+0];
					uint index1=indices[s+1];
					uint index2=indices[s+2];
					v0=vertexCoordinate(vertices,index0);
					v1=vertexCoordinate(vertices,index1);
					v2=vertexCoordinate(vertices,index2);
					float4 intersectInfo=intersectTriangle(v0,v1,v2,origin,direction);
					float distance=intersectInfo.s0;
					if(distance<minDistance)
					{
						newPosition=origin+distance*direction;
						if(isInGrid(newPosition,gridMin,gridIntervals,gridCoord))
						{
							t=intersectInfo.s123;
							n0=vertexNormal(vertices,index0);
							n1=vertexNormal(vertices,index1);
							n2=vertexNormal(vertices,index2);
							newNormal=normalize(interpolateVector(t,n0,n1,n2));
							if(isVisible(newNormal,direction))
							{
								intersection=1.0;
								position=newPosition;
								normal=newNormal;
								c0=vertexColor(vertices,index0);
								c1=vertexColor(vertices,index1);
								c2=vertexColor(vertices,index2);
								color=interpolateVector(t,c0,c1,c2);
								minDistance=distance;
							}
						}
					}
				}
				return (float16)(intersection,position,normal,color,minDistance,0,0,0,0,0);
			}
			inline int sig(float x,int a,int b){return x<0?a:b;}
			inline int3 sigFloat3(float3 xyz,int a,int b){return (int3)(sig(xyz.s0,a,b),sig(xyz.s1,a,b),sig(xyz.s2,a,b));}
			inline float3 absFloat3(float3 xyz){return (float3)(Abs(xyz.s0),Abs(xyz.s1),Abs(xyz.s2));}
			inline float minFloat3(float3 xyz){return min(xyz.s0,min(xyz.s1,xyz.s2));}
			inline float maxFloat3(float3 xyz){return max(xyz.s0,max(xyz.s1,xyz.s2));}
			inline float3 distanceToGrid(float3 origin,float3 direction,float3 gridMin,float3 gridIntervals,int3 gridCoord)
			{
				float3 position=gridMin+gridIntervals*Float3(gridCoord+sigFloat3(direction,0,1));
				return (position-origin)/direction;
			}
			inline float16 intersectObject(__global uint* primaryIndices,__global uint* secondaryIndices,__global uint* indices,__global float* vertices,float8 boundingBox,int3 gridSize,float3 origin,float3 direction,float distance,float maxDistance)
			{
				int3 zero=(int3)(0),one=(int3)(1);
				float3 minXYZ=boundingBox.s012;
				float3 maxXYZ=boundingBox.s345;
				float3 dXYZ=(maxXYZ-minXYZ)/Float3(gridSize);
				float3 position=origin+direction*distance;
				int3 gridCoord=clamp(getGridCoord(position,minXYZ,dXYZ),zero,gridSize-one);
				float16 intersection=intersectObjectInGrid(primaryIndices,secondaryIndices,indices,vertices,minXYZ,dXYZ,gridCoord,gridSize,origin,direction);
				if(intersection.s0)return intersection;
				int3 incCoord=sigFloat3(direction,-1,1);
				float3 incDistance=dXYZ/absFloat3(direction);
				float3 gridDistance=distanceToGrid(origin,direction,minXYZ,dXYZ,gridCoord);
				distance=minFloat3(gridDistance);
				while(distance<=maxDistance)
				{
					if(distance==gridDistance.s0)
					{
						gridCoord.s0+=incCoord.s0;
						gridDistance.s0+=incDistance.s0;
					}
					else if(distance==gridDistance.s1)
					{
						gridCoord.s1+=incCoord.s1;
						gridDistance.s1+=incDistance.s1;
					}
					else if(distance==gridDistance.s2)
					{
						gridCoord.s2+=incCoord.s2;
						gridDistance.s2+=incDistance.s2;
					}
					gridCoord=clamp(gridCoord,zero,gridSize-one);
					intersection=intersectObjectInGrid(primaryIndices,secondaryIndices,indices,vertices,minXYZ,dXYZ,gridCoord,gridSize,origin,direction);
					if(intersection.s0)return intersection;
					distance=minFloat3(gridDistance);
				}
				return intersection;
			}
			inline float isOnShadow(__global uint* primaryIndices,__global uint* secondaryIndices,__global uint* indices,__global float* vertices,float8 boundingBox,int3 gridSize,float3 position,float3 lightPosition)
			{
				float lightDistance=length(lightPosition-position);
				float3 lightDirection=(lightPosition-position)/lightDistance;
				float maxDistance=intersectCube(boundingBox,position,lightDirection).s1;
				float16 intersection=intersectObject(primaryIndices,secondaryIndices,indices,vertices,boundingBox,gridSize,position,lightDirection,0.0,maxDistance);
				float minDistance=intersection.sa;if(minDistance>lightDistance)return 0.0;
				return intersection.s0;
			}
			inline uchar4 pixelColor(float3 color)
			{
				uint r=(uint)(color.s0*255);
				uint g=(uint)(color.s1*255);
				uint b=(uint)(color.s2*255);
				return (uchar4)(r,g,b,255);
			}
			inline float3 colorPixel(uchar4 pixel)
			{
				float r=pixel.s0/255.0;
				float g=pixel.s1/255.0;
				float b=pixel.s2/255.0;
				return (float3)(r,g,b);
			}
			inline float GaussDecay(float distance,float interval)
			{
				float PI=3.1415926535;
				float d=interval/2;
				float u=distance/d;
				float k=sqrt(2*PI)*d;
				return exp(-u*u/2)/k;
			}
			inline float3 photonPosition(__global float* photonInfo,uint index)
			{
				return (float3)(photonInfo[index*10+0],photonInfo[index*10+1],photonInfo[index*10+2]);
			}
			inline float photonDistance(__global float* photonInfo,uint index)
			{
				return photonInfo[index*10+3];
			}
			inline float3 photonDirection(__global float* photonInfo,uint index)
			{
				return (float3)(photonInfo[index*10+4],photonInfo[index*10+5],photonInfo[index*10+6]);
			}
			inline float3 photonColor(__global float* photonInfo,uint index)
			{
				return (float3)(photonInfo[index*10+7],photonInfo[index*10+8],photonInfo[index*10+9]);
			}
			inline float3 photonColorInGrid(int3 gridCoord,float interval,float3 position,float3 normal,float3 color,__global float* positionX, __global float* positionY, __global float* positionZ,__global float* directionX, __global float* directionY, __global float* directionZ,__global uint* primaryIndices,__global uint* secondaryIndices, __global float* photonInfo,int3 gridSize)
			{
				int j=gridCoord.s0,k=gridCoord.s1,i=gridCoord.s2;
				int column=gridSize.s0,level=gridSize.s1,row=gridSize.s2;
				uint p=primaryIndices[k*row*column+i*column+j];
				uint length1=secondaryIndices[p++];
				float photonDecay,colorDecay,distanceDecay,weight=0.0;
				float3 resultColor=(float3)0.0,incrementColor,direction,distance;
				for(i=0;i<length1;i++)
				{
					uint s=secondaryIndices[p++];
					direction=photonDirection(photonInfo,s);
					distance=photonPosition(photonInfo,s)-position;
					photonDecay=GaussDecay(length(distance),interval);
					distanceDecay=lightDecay(photonDistance(photonInfo,s));
					colorDecay=max(dot(-direction,normal),0.0)*distanceDecay;
					resultColor+=color*photonDecay*colorDecay*photonColor(photonInfo,s);
				}
				return resultColor;
			}
			inline float3 irradianceColor(float3 position,float3 normal,float3 color,float8 boundingBox,__global float* positionX, __global float* positionY, __global float* positionZ,__global float* directionX, __global float* directionY, __global float* directionZ,__global uint* primaryIndices,__global uint* secondaryIndices, __global float* photonInfo, int3 gridSize)
			{
				int3 zero=(int3)(0),one=(int3)(1);
				float3 photonColor=(float3)0.0;
				float3 minXYZ=boundingBox.s012;
				float3 maxXYZ=boundingBox.s345;
				float3 dXYZ=(maxXYZ-minXYZ)/Float3(gridSize);
				float interval=(dXYZ.s0+dXYZ.s1+dXYZ.s2)/3.0;
				int3 gridCoord0=clamp(getGridCoord(position-dXYZ,minXYZ,dXYZ),zero,gridSize-one);
				int3 gridCoord1=clamp(getGridCoord(position+dXYZ,minXYZ,dXYZ),zero,gridSize-one);
				int n0=gridCoord0.s0,l0=gridCoord0.s1,m0=gridCoord0.s2;
				int n1=gridCoord1.s0,l1=gridCoord1.s1,m1=gridCoord1.s2;
				for(int j=n0;j<=n1;j++)
				{
					for(int k=l0;k<=l1;k++)
					{
						for(int i=m0;i<=m1;i++)
						{
							int3 gridCoord=(int3)(j,k,i);
							photonColor+=photonColorInGrid(gridCoord,interval,position,normal,color,positionX,positionY,positionZ, directionX, directionY, directionZ,primaryIndices,secondaryIndices,photonInfo,gridSize);
						}
					}
				}
				return photonColor;
			}
			inline float3 refract(float3 L,float3 N,float eta)
			{
				float k=max(1.0-eta*eta*(1.0-dot(N,L)*dot(N,L)),0.0);
				return eta*L-(eta*dot(N,L)+sqrt(k))*N;
			}
			float isGlass(float3 color)
			{
				return (color.s0+color.s1+color.s2<-MaxError)?1.0:0.0;
			}
			__kernel void main(float3 renderInfo,float8 boundingBox,__global uchar4* pixels,__global float* positionX, __global float* positionY, __global float* positionZ, __global float* directionX, __global float* directionY, __global float* directionZ, float16 viewInfo,float8 lightInfo,__global uint* primaryIndices,__global uint* secondaryIndices,__global uint* indices,__global float* vertices,int3 gridSize,__global float* photonPosX, __global float* photonPosY, __global float* photonPosZ,__global float* photonDirX, __global float* photonDirY, __global float* photonDirZ,__global uint* photonPriIndices,__global uint* photonSecIndices,__global float* photonInfo,int3  photonGridSize,uint2 imageSize)
			{
				uint height=imageSize.s0,width=imageSize.s1;
				uint row=get_global_id(0),col=get_global_id(1);
				uint pixelIndex=(height-1-row)*width+col;
				if(row>=height||col>=width)return;
				float shadowDecay=1.0;
				float reflectionDecay=lightInfo.s7;
				float3 eyePosition=viewInfo.s012;
				float2 lensInfo=renderInfo.s12;
				float3 viewDirection=getViewDirection(viewInfo,lensInfo,row,col,imageSize);
				float3 lightPosition=lightInfo.s012,position,direction,normal,color,viewColor;
				float time=renderInfo.s0;
				if(time==0.0)
				{
					pixels[pixelIndex]=(uchar4)(0,0,0,255);
					position=eyePosition;
					direction=viewDirection;
				}
				else
				{
					position=(float3)(positionX[pixelIndex],positionY[pixelIndex],positionZ[pixelIndex]);
					direction=(float3)(directionX[pixelIndex],directionY[pixelIndex],directionZ[pixelIndex]);
				}
				float n0=1.0,n1=1.08,eta=n0/n1;float3 glassColor;
				float2 distance=intersectCube(boundingBox,position,direction);
				if(distance.s0==MaxDistance)viewColor=(float3)(0.0);
				else
				{
					float16 intersection=intersectObject(primaryIndices,secondaryIndices,indices,vertices,boundingBox,gridSize,position,direction,distance.s0,distance.s1);
					if(intersection.s0)
					{
						position=intersection.s123;
						normal=intersection.s456;
						color=intersection.s789;
						if(isGlass(color))
						{
							glassColor=-color;
							direction=refract(direction,normal,eta);
							distance=intersectCube(boundingBox,position,direction);
							if(distance.s0==MaxDistance)viewColor=(float3)(0.0);
							else
							{
								intersection=intersectObject(primaryIndices,secondaryIndices,indices,vertices,boundingBox,gridSize,position,direction,distance.s0,distance.s1);
								if(intersection.s0)
								{
									position=intersection.s123;
									normal=intersection.s456;
									color=intersection.s789;
									viewColor=glassColor*irradianceColor(position,normal,color,boundingBox,photonPosX,photonPosY,photonPosZ, photonDirX, photonDirY, photonDirZ,photonPriIndices,photonSecIndices,photonInfo,photonGridSize);
								}
								else viewColor=(float3)(0.0);
							}
						}
						else viewColor=irradianceColor(position,normal,color,boundingBox,photonPosX,photonPosY,photonPosZ, photonDirX, photonDirY, photonDirZ,photonPriIndices,photonSecIndices,photonInfo,photonGridSize);
						direction=reflect(direction,normal);
					}
					else viewColor=(float3)(0.0);
				}
				float colorDecay=shadowDecay*pow(reflectionDecay,time);
				float3 newColor=colorPixel(pixels[pixelIndex])+viewColor*colorDecay;
				pixels[pixelIndex]=pixelColor(clamp(newColor,0.0,1.0));
				positionX[pixelIndex]=position.s0;
				positionY[pixelIndex]=position.s1;
				positionZ[pixelIndex]=position.s2;
				directionX[pixelIndex]=direction.s0;
				directionY[pixelIndex]=direction.s1;
				directionZ[pixelIndex]=direction.s2;
			}
		</script>
		<script id="webcl-kernel1" type="x-kernel">
			__constant float MaxError=0.00001,MaxDistance=10000.0;
			__constant float3 objectColor=(float3)(1.0,0.0,0.0);
			inline float Abs(float x){return x>0?x:-x;}
			inline float4 intersectTriangle(float3 v0,float3 v1,float3 v2,float3 origin,float3 direction)
			{
				float4 noIntersection=(float4)(MaxDistance,0,0,0);
				float3 d=direction,p=origin;
				float3 e1=v1-v0,e2=v2-v0;
				float3 h=cross(d,e2);
				float a=dot(e1,h);
				if(Abs(a)<MaxError)return noIntersection;
				float f=1.0/a;
				float3 s=p-v0;
				float u=f*dot(s,h);
				if (u < 0.0 || u > 1.0)return noIntersection;
				float3 q=cross(s,e1);
				float v=f*dot(d,q);
				if (v < 0.0 || u + v > 1.0)return noIntersection;
				float t=f*dot(e2,q);
				if(t>MaxError)return (float4)(t,1.0-u-v,u,v);
				else return noIntersection;
			}
			float2 intersectCube(float8 cubeMinMax,float3 origin,float3 direction)
			{
				float3 cubeMin=cubeMinMax.s012;
				float3 cubeMax=cubeMinMax.s345;
				float3 tMin=(cubeMin-origin)/direction;
				float3 tMax=(cubeMax-origin)/direction;
				float2 ErrorDistance=(float2)(MaxDistance);
				float3 t1=min(tMin,tMax),t2=max(tMin,tMax);
				float tNear=max(max(t1.x,t1.y),t1.z);
				float tFar=min(min(t2.x,t2.y),t2.z);
				if(tNear>tFar)return ErrorDistance;
				else return (float2)(tNear,tFar);
			}
			inline float3 reflect(float3 L,float3 N)
			{
				return L-2.0*dot(L,N)*N;
			}
			inline float lightDecay(float lightDistance)
			{
				float lightDistance2=pow(lightDistance,2.0)+MaxError;
				return 1.0/lightDistance2;
			}
			inline float3 vertexCoordinate(__global float* vertices,uint index)
			{
				return (float3)(vertices[index*9+0],vertices[index*9+1],vertices[index*9+2]);
			}
			inline float3 vertexNormal(__global float* vertices,uint index)
			{
				return (float3)(vertices[index*9+3],vertices[index*9+4],vertices[index*9+5]);
			}
			inline float3 vertexColor(__global float* vertices,uint index)
			{
				return (float3)(vertices[index*9+6],vertices[index*9+7],vertices[index*9+8]);
			}
			inline float3 interpolateVector(float3 t,float3 v0,float3 v1,float3 v2)
			{
				return v0*t.s0+v1*t.s1+v2*t.s2;
			}
			inline float3 Float3(int3 x){return (float3)(x.s0,x.s1,x.s2);}
			inline int3 Int3(float3 x){return (int3)(x.s0,x.s1,x.s2);}
			inline bool between(float3 x,float3 l,float3 g)
			{
				bool b0=l.s0<=x.s0&&x.s0<=g.s0;
				bool b1=l.s1<=x.s1&&x.s1<=g.s1;
				bool b2=l.s2<=x.s2&&x.s2<=g.s2;
				return b0&&b1&&b2;
			}
			inline float3 propagateRay(float3 origin,float3 direction,float3 distance)
			{
				return origin+(distance+MaxError)*direction;
			}
			inline int3 getGridCoord(float3 position,float3 gridMin,float3 gridIntervals)
			{
				return Int3((position-gridMin)/gridIntervals);
			}
			inline bool isInGrid(float3 position,float3 gridMin,float3 gridIntervals,int3 gridCoord)
			{
				float3 minPosition=gridMin+gridIntervals*Float3(gridCoord);
				float3 maxPosition=minPosition+gridIntervals;
				return between(position,minPosition,maxPosition);
			}
			inline float isVisible(float3 normal,float3 direction)
			{
				return dot(direction,normal)<=0?1.0:0.0;
			}
			inline float16 intersectObjectInGrid(__global uint* primaryIndices,__global uint* secondaryIndices,__global uint* indices,__global float* vertices,float3 gridMin,float3 gridIntervals,int3 gridCoord,int3 gridSize,float3 origin,float3 direction)
			{
				float3 newPosition,newNormal;
				float3 v0,v1,v2,t,n0,n1,n2,c0,c1,c2;
				float3 position,normal,color=(float3)(0.0);
				float minDistance=MaxDistance,intersection=0.0;
				int j=gridCoord.s0,k=gridCoord.s1,i=gridCoord.s2;
				int column=gridSize.s0,level=gridSize.s1,row=gridSize.s2;
				uint p=primaryIndices[k*row*column+i*column+j];
				uint length=secondaryIndices[p++];
				for(i=0;i<length;i++)
				{
					uint s=secondaryIndices[p++];
					uint index0=indices[s+0];
					uint index1=indices[s+1];
					uint index2=indices[s+2];
					v0=vertexCoordinate(vertices,index0);
					v1=vertexCoordinate(vertices,index1);
					v2=vertexCoordinate(vertices,index2);
					float4 intersectInfo=intersectTriangle(v0,v1,v2,origin,direction);
					float distance=intersectInfo.s0;
					if(distance<minDistance)
					{
						newPosition=origin+distance*direction;
						if(isInGrid(newPosition,gridMin,gridIntervals,gridCoord))
						{
							t=intersectInfo.s123;
							n0=vertexNormal(vertices,index0);
							n1=vertexNormal(vertices,index1);
							n2=vertexNormal(vertices,index2);
							newNormal=normalize(interpolateVector(t,n0,n1,n2));
							if(isVisible(newNormal,direction))
							{
								intersection=1.0;
								position=newPosition;
								normal=newNormal;
								c0=vertexColor(vertices,index0);
								c1=vertexColor(vertices,index1);
								c2=vertexColor(vertices,index2);
								color=interpolateVector(t,c0,c1,c2);
								minDistance=distance;
							}
						}
					}
				}
				return (float16)(intersection,position,normal,color,minDistance,0,0,0,0,0);
			}
			inline int sig(float x,int a,int b){return x<0?a:b;}
			inline int3 sigFloat3(float3 xyz,int a,int b){return (int3)(sig(xyz.s0,a,b),sig(xyz.s1,a,b),sig(xyz.s2,a,b));}
			inline float3 absFloat3(float3 xyz){return (float3)(Abs(xyz.s0),Abs(xyz.s1),Abs(xyz.s2));}
			inline float minFloat3(float3 xyz){return min(xyz.s0,min(xyz.s1,xyz.s2));}
			inline float3 distanceToGrid(float3 origin,float3 direction,float3 gridMin,float3 gridIntervals,int3 gridCoord)
			{
				float3 position=gridMin+gridIntervals*Float3(gridCoord+sigFloat3(direction,0,1));
				return (position-origin)/direction;
			}
			inline float16 intersectObject(__global uint* primaryIndices,__global uint* secondaryIndices,__global uint* indices,__global float* vertices,float8 boundingBox,int3 gridSize,float3 origin,float3 direction,float distance,float maxDistance)
			{
				int3 zero=(int3)(0),one=(int3)(1);
				float3 minXYZ=boundingBox.s012;
				float3 maxXYZ=boundingBox.s345;
				float3 dXYZ=(maxXYZ-minXYZ)/Float3(gridSize);
				float3 position=origin+direction*distance;
				int3 gridCoord=clamp(getGridCoord(position,minXYZ,dXYZ),zero,gridSize-one);
				float16 intersection=intersectObjectInGrid(primaryIndices,secondaryIndices,indices,vertices,minXYZ,dXYZ,gridCoord,gridSize,origin,direction);
				if(intersection.s0)return intersection;
				int3 incCoord=sigFloat3(direction,-1,1);
				float3 incDistance=dXYZ/absFloat3(direction);
				float3 gridDistance=distanceToGrid(origin,direction,minXYZ,dXYZ,gridCoord);
				distance=minFloat3(gridDistance);
				while(distance<=maxDistance)
				{
					if(distance==gridDistance.s0)
					{
						gridCoord.s0+=incCoord.s0;
						gridDistance.s0+=incDistance.s0;
					}
					else if(distance==gridDistance.s1)
					{
						gridCoord.s1+=incCoord.s1;
						gridDistance.s1+=incDistance.s1;
					}
					else if(distance==gridDistance.s2)
					{
						gridCoord.s2+=incCoord.s2;
						gridDistance.s2+=incDistance.s2;
					}
					gridCoord=clamp(gridCoord,zero,gridSize-one);
					intersection=intersectObjectInGrid(primaryIndices,secondaryIndices,indices,vertices,minXYZ,dXYZ,gridCoord,gridSize,origin,direction);
					if(intersection.s0)return intersection;
					distance=minFloat3(gridDistance);
				}
				return intersection;
			}
			float3 sphereDirection(float2 texCoord)
			{
				float s=texCoord.s0;
				float t=texCoord.s1;
				float PI=3.1415926;
				float v=s*2*PI,u=t*PI;
				float x=sin(u)*cos(v);
				float y=cos(u);
				float z=sin(u)*sin(v);
				return (float3)(x,y,z);
			}
			inline float3 refract(float3 L,float3 N,float eta)
			{
				float k=max(1.0-eta*eta*(1.0-dot(N,L)*dot(N,L)),0.0);
				return eta*L-(eta*dot(N,L)+sqrt(k))*N;
			}
			float isGlass(float3 color)
			{
				return (color.s0+color.s1+color.s2<-MaxError)?1.0:0.0;
			}
			inline float3 vertical(float3 direction)
			{
				if(Abs(direction.x)<0.5) return cross(direction,(float3)(1,0,0));
				else return cross(direction,(float3)(0,1,0));
			}
			float3 randomDirection(float3 normal,float u,float v)
			{
				float r = sqrt(u),angle = 6.283185307179586 * v;
				float3 n=normal,d=vertical(n),t=cross(n,d),b=cross(n,t);
				float3 randir=r*cos(angle)*t + r*sin(angle)*b + sqrt(1.0-u)*n;
				return normalize(randir);
			}
			__kernel void main(float time,float8 boundingBox,__global float* positionX, __global float* positionY, __global float* positionZ, __global float* positionW, __global float* directionX, __global float* directionY, __global float* directionZ, __global float* normalX, __global float* normalY, __global float* normalZ, __global float* colorR, __global float* colorG, __global float* colorB, __global float* red, __global float* green, __global float* blue, __global float* random, float8 lightInfo,__global uint* primaryIndices,__global uint* secondaryIndices,__global uint* indices,__global float* vertices,int3 gridSize,uint2 imageSize)
			{
				uint height=imageSize.s0,width=imageSize.s1;
				uint row=get_global_id(0),col=get_global_id(1);
				uint pixelIndex=(row)*width+col;
				if(row>=height||col>=width)return;
				float t=(row+0.0)/height;
				float s=(col+0.0)/width;
				float photonDistance;
				float3 photonColor,color;
				float3 position,direction,normal;
				float rand1=random[row*col%(height-1)];
				float rand2=random[(height-1-row)*col%(height-1)];
				if(time==0.0)
				{
					position=lightInfo.s012;
					photonColor=lightInfo.s345*lightInfo.s6/(height*width);
					direction=sphereDirection((float2)(s,t*4));
					photonDistance=0;
				}
				else
				{
					if(positionX[pixelIndex]==-MaxDistance)return;
					position=(float3)(positionX[pixelIndex],positionY[pixelIndex],positionZ[pixelIndex]);
					normal=(float3)(normalX[pixelIndex],normalY[pixelIndex],normalZ[pixelIndex]);
					direction=randomDirection(normal,rand1,rand2);
					photonDistance=positionW[pixelIndex];
					photonColor=(float3)(colorR[pixelIndex],colorG[pixelIndex],colorB[pixelIndex]);
					photonColor*=(float3)(red[pixelIndex],green[pixelIndex],blue[pixelIndex]);
				}
				float n0=1.0,n1=1.08,eta=n0/n1;float3 glassColor;
				float2 distance=intersectCube(boundingBox,position,direction);
				if(distance.s0==MaxDistance){positionX[pixelIndex]=-MaxDistance;return;}
				else
				{
					float16 intersection=intersectObject(primaryIndices,secondaryIndices,indices,vertices,boundingBox,gridSize,position,direction,distance.s0,distance.s1);
					if(intersection.s0)
					{
						position=intersection.s123;
						normal=intersection.s456;
						color=intersection.s789;
						if(time==0.0)photonDistance+=intersection.sa;
						if(isGlass(color))
						{
							glassColor=-color;
							direction=refract(direction,normal,eta);
							distance=intersectCube(boundingBox,position,direction);
							if(distance.s0==MaxDistance){positionX[pixelIndex]=-MaxDistance;return;}
							else
							{
								intersection=intersectObject(primaryIndices,secondaryIndices,indices,vertices,boundingBox,gridSize,position,direction,distance.s0,distance.s1);
								if(intersection.s0)
								{
									position=intersection.s123;
									normal=intersection.s456;
									color=intersection.s789;
									photonColor*=glassColor;
									if(time==0.0)photonDistance+=intersection.sa;
								}
								else {positionX[pixelIndex]=-MaxDistance;return;}
							}
						}
					}
					else {positionX[pixelIndex]=-MaxDistance;return;}
				}
				positionX[pixelIndex]=position.s0;
				positionY[pixelIndex]=position.s1;
				positionZ[pixelIndex]=position.s2;
				positionW[pixelIndex]=photonDistance;
				directionX[pixelIndex]=direction.s0;
				directionY[pixelIndex]=direction.s1;
				directionZ[pixelIndex]=direction.s2;
				normalX[pixelIndex]=normal.s0;
				normalY[pixelIndex]=normal.s1;
				normalZ[pixelIndex]=normal.s2;
				colorR[pixelIndex]=photonColor.s0;
				colorG[pixelIndex]=photonColor.s1;
				colorB[pixelIndex]=photonColor.s2;
				red[pixelIndex]=color.s0;
				green[pixelIndex]=color.s1;
				blue[pixelIndex]=color.s2;
			}
		</script>
		<script>
			var cl=null;
			var device_id=0;
			var kernel_id="webcl-kernel";
			var kernel1_id="webcl-kernel1";
			var canvas_id="webcl-canvas";
			var photon_id="webcl-photon";
			function main()
			{
				clCreateContext(true);
				clCreateKernels([kernel_id,kernel1_id]);
				clCreateGeometryInfo("GeometryInfo");
				clCreateCanvas(canvas_id,550,550);
				clCreatePhotonMap(photon_id,400,800);
				clAddEventListener();
				clUpdateViewInfo();
				clUpdateLightInfo();
				clCreatePhotonInfo();
				clDisplayFunc();
			}
			function clCreateContext(useGPU)
			{
				if(cl==null)
				{
					if(typeof(webcl)=="undefined")alert("Webcl is undefined");
					if(webcl===null){alert("No webcl object available");return;}
					cl=[];cl.canvas=[];cl.devices=[];cl.photonMap=[];
					var platforms=webcl.getPlatforms(),devices=[];
					if(platforms.length==0){alert("No platforms available");return;}
					for(var i in platforms)
					{
						if(useGPU)devices=platforms[i].getDevices(webcl.DEVICE_TYPE_GPU);
						else devices=platforms[i].getDevices(webcl.DEVICE_TYPE_CPU);
						for(var j in devices)cl.devices.push(devices[j]);
					}
				}
				var device=cl.devices[device_id];
				var context=webcl.createContext(device);
				context.photonMap=cl.photonMap;
				context.canvas=cl.canvas;
				context.devices=cl.devices;
				cl=context;
			}
			function clCreateKernels(ids)
			{
				if(cl.devices.length==0){alert("No devices available");return;}
				cl.kernels=[];
				for(var i=0;i<ids.length;i++)
				{
					var id=ids[i],kernelSource=clGetKernelSource(id);
					var program=cl.createProgram(kernelSource);
					program.build();
					cl.kernels[id]=program.createKernel("main");
					cl.kernels[id].commandQueue=cl.createCommandQueue();
				}
			}
			function clCreateCanvas(id,width,height)
			{
				var canvas=document.getElementById(id);
				canvas.width=width;canvas.height=height;
				canvas.element=document.createElement('canvas');
				canvas.element.setAttribute("id",id);
				canvas.element.setAttribute("width",width);
				canvas.element.setAttribute("height",height);
				canvas.appendChild(canvas.element);
				canvas.context=canvas.element.getContext("2d");
				canvas.image=canvas.context.createImageData(width,height);
				canvas.pixelBuffer=cl.createBuffer(webcl.MEM_WRITE_ONLY,height*width*4);
				canvas.positionXBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				canvas.positionYBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				canvas.positionZBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				canvas.directionXBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				canvas.directionYBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				canvas.directionZBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				canvas.positionXBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				canvas.positionYBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				canvas.positionZBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				canvas.directionXBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				canvas.directionYBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				canvas.directionZBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				canvas.sizeArray=new Uint32Array([height,width]);
				canvas.pixelBuffer.length=height*width*4;
				canvas.viewSize=[1,width/height];
				cl.canvas[id]=canvas;
			}
			function clCreatePhotonMap(id,width,height)
			{
				var photonMap=[];
				photonMap.width=width;photonMap.height=height;
				photonMap.positionXBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				photonMap.positionYBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				photonMap.positionZBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				photonMap.positionWBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				photonMap.directionXBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				photonMap.directionYBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				photonMap.directionZBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				photonMap.normalXBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				photonMap.normalYBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				photonMap.normalZBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				photonMap.colorRBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				photonMap.colorGBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				photonMap.colorBBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				photonMap.redBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				photonMap.greenBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				photonMap.blueBuffer=cl.createBuffer(webcl.MEM_READ_WRITE,height*width*Float32Array.BYTES_PER_ELEMENT);
				photonMap.randomBuffer=cl.createBuffer(webcl.MEM_READ_ONLY,height*Float32Array.BYTES_PER_ELEMENT);
				photonMap.positionXBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				photonMap.positionYBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				photonMap.positionZBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				photonMap.positionWBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				photonMap.directionXBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				photonMap.directionYBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				photonMap.directionZBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				photonMap.normalXBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				photonMap.normalYBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				photonMap.normalZBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				photonMap.colorRBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				photonMap.colorGBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				photonMap.colorBBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				photonMap.redBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				photonMap.greenBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				photonMap.blueBuffer.length=height*width*Float32Array.BYTES_PER_ELEMENT;
				photonMap.randomBuffer.length=height*Float32Array.BYTES_PER_ELEMENT;
				photonMap.positionXArray=new Float32Array(height*width);
				photonMap.positionYArray=new Float32Array(height*width);
				photonMap.positionZArray=new Float32Array(height*width);
				photonMap.positionWArray=new Float32Array(height*width);
				photonMap.directionXArray=new Float32Array(height*width);
				photonMap.directionYArray=new Float32Array(height*width);
				photonMap.directionZArray=new Float32Array(height*width);
				photonMap.colorRArray=new Float32Array(height*width);
				photonMap.colorGArray=new Float32Array(height*width);
				photonMap.colorBArray=new Float32Array(height*width);
				photonMap.randomArray=new Float32Array(height*1);
				photonMap.sizeArray=new Uint32Array([height,width]);
				photonMap.viewSize=[1,width/height];
				cl.photonMap[id]=photonMap;
			}
			var translate=[0,0,0],scale=0.08;
			var level=5,row=5,column=5;
			var objectGridSizeArray=new Int32Array([column,level,row]);
			var objectBoundingBox,objectVerticesArray,objectVerticesBuffer;
			var objectPrimaryIndicesArray,objectPrimaryIndicesBuffer;
			var objectSecondaryIndicesArray,objectSecondaryIndicesBuffer;
			function clCreateGeometryInfo(geometryID)
			{
				var gl=new Geometry();
				var CornelBox=getJsonObjectData("object/CornelBox");
				gl.pushMatrix();
				gl.translate(0,-1.5,0);
				gl.scale(1.5,1.5,1.5);
				gl.addObject(CornelBox);
				gl.popMatrix();

				var geometryInfo=gl.getGeometryInfo();
				var indicesLength=geometryInfo.indices.length,k=0;
				var verticesLength=geometryInfo.coordinates.length;
				var Uint32Size=Uint32Array.BYTES_PER_ELEMENT;
				var Float32Size=Float32Array.BYTES_PER_ELEMENT;
				objectIndicesArray=new Uint32Array(Uint32Size*indicesLength);
				objectVerticesArray=new Float32Array(Float32Size*verticesLength*3);
				objectIndicesBuffer=cl.createBuffer(webcl.MEM_READ_ONLY,Uint32Size*indicesLength);
				objectVerticesBuffer=cl.createBuffer(webcl.MEM_READ_ONLY,Float32Size*verticesLength*3);
				for(var i=0;i<indicesLength;i++)objectIndicesArray[i]=geometryInfo.indices[i];
				clCreateBoundingBox(geometryID);
				for(var i=0;i<verticesLength;i+=3)
				{
					objectVerticesArray[k++]=geometryInfo.coordinates[i+0];
					objectVerticesArray[k++]=geometryInfo.coordinates[i+1];
					objectVerticesArray[k++]=geometryInfo.coordinates[i+2];
					objectVerticesArray[k++]=geometryInfo.normals[i+0];
					objectVerticesArray[k++]=geometryInfo.normals[i+1];
					objectVerticesArray[k++]=geometryInfo.normals[i+2];
					objectVerticesArray[k++]=geometryInfo.colors[i+0];
					objectVerticesArray[k++]=geometryInfo.colors[i+1];
					objectVerticesArray[k++]=geometryInfo.colors[i+2];
					clUpdateBoundingBox(geometryID,objectVerticesArray,k-9);
				}
				clWriteKernelBuffer(kernel_id,objectIndicesArray,objectIndicesBuffer,Uint32Size*indicesLength);
				clWriteKernelBuffer(kernel_id,objectVerticesArray,objectVerticesBuffer,Float32Size*verticesLength*3);
				objectBoundingBox=clGetBoundingBox(geometryID);
				var level=objectGridSizeArray[0],row=objectGridSizeArray[1],column=objectGridSizeArray[2];
				var objectGrid=new ObjectUniformGrid(geometryInfo,objectBoundingBox,level,row,column);
				objectPrimaryIndicesArray=objectGrid.getPrimaryIndicesArray();
				objectSecondaryIndicesArray=objectGrid.getSecondaryIndicesArray();
				objectPrimaryIndicesBuffer=cl.createBuffer(webcl.MEM_READ_ONLY,objectPrimaryIndicesArray.size);
				objectSecondaryIndicesBuffer=cl.createBuffer(webcl.MEM_READ_ONLY,objectSecondaryIndicesArray.size);
				clWriteKernelBuffer(kernel_id,objectPrimaryIndicesArray,objectPrimaryIndicesBuffer,objectPrimaryIndicesArray.size);
				clWriteKernelBuffer(kernel_id,objectSecondaryIndicesArray,objectSecondaryIndicesBuffer,objectSecondaryIndicesArray.size);
			}
			function clTransformObjectCoordinates(objectData,i,zoom,translation)
			{
				objectData.coordinates[i+0]=objectData.coordinates[i+0]*zoom+translation[0];
				objectData.coordinates[i+1]=objectData.coordinates[i+1]*zoom+translation[1];
				objectData.coordinates[i+2]=objectData.coordinates[i+2]*zoom+translation[2];
			}
			var clBoundingBox=[],MAX=1e10,MIN=-MAX;
			function clCreateBoundingBox(id)
			{
				clBoundingBox[id]=[];
				clBoundingBox[id].min=new Vector3([MAX,MAX,MAX]);
				clBoundingBox[id].max=new Vector3([MIN,MIN,MIN]);
			}
			function clUpdateBoundingBox(id,array,i)
			{
				var xyz=[array[i+0],array[i+1],array[i+2]];
				clBoundingBox[id].min.minimize(xyz);
				clBoundingBox[id].max.maximize(xyz);
			}
			function clGetBoundingBox(id)
			{
				var Error=0.00001;
				var s0=clBoundingBox[id].min.elements[0]-Error;
				var s1=clBoundingBox[id].min.elements[1]-Error;
				var s2=clBoundingBox[id].min.elements[2]-Error;
				var s3=clBoundingBox[id].max.elements[0]+Error;
				var s4=clBoundingBox[id].max.elements[1]+Error;
				var s5=clBoundingBox[id].max.elements[2]+Error;
				return new Float32Array([s0,s1,s2,s3,s4,s5,0,0]);
			}
			var K=70,level=K,row=K,column=K;
			var photonInfoArray,photonInfoBuffer;
			var photonGridSizeArray=new Int32Array([column,level,row]);
			var photonPrimaryIndicesArray,photonPrimaryIndicesBuffer;
			var photonSecondaryIndicesArray,photonSecondaryIndicesBuffer;
			function clCreatePhotonInfo()
			{
				var level=photonGridSizeArray[0],row=photonGridSizeArray[1],column=photonGridSizeArray[2];
				var photonGrid=new PhotonUniformGrid(objectBoundingBox,level,row,column);
				var times=2;
				var time=new Float32Array([0])
				for(var i=0;i<times;i++)
				{
					time[0]=i;
					if(i>0)clUpdateRandomBuffer();
					var photonInfo=clGetPhotonInfo(time);
					photonGrid.addPhotonInfo(photonInfo);
				}
				photonGrid.createIndexTables();
				var Float32Size=Float32Array.BYTES_PER_ELEMENT;
				photonInfoArray=new Float32Array(photonGrid.photonInfoTable);
				photonInfoBuffer=cl.createBuffer(webcl.MEM_READ_ONLY,photonInfoArray.byteLength);
				clWriteKernelBuffer(kernel_id,photonInfoArray,photonInfoBuffer,photonInfoArray.byteLength);
				photonPrimaryIndicesArray=photonGrid.getPrimaryIndicesArray();
				photonSecondaryIndicesArray=photonGrid.getSecondaryIndicesArray();
				photonPrimaryIndicesBuffer=cl.createBuffer(webcl.MEM_READ_ONLY,photonPrimaryIndicesArray.size);
				photonSecondaryIndicesBuffer=cl.createBuffer(webcl.MEM_READ_ONLY,photonSecondaryIndicesArray.size);
				clWriteKernelBuffer(kernel_id,photonPrimaryIndicesArray,photonPrimaryIndicesBuffer,photonPrimaryIndicesArray.size);
				clWriteKernelBuffer(kernel_id,photonSecondaryIndicesArray,photonSecondaryIndicesBuffer,photonSecondaryIndicesArray.size);
			}
			function clGetPhotonInfo(time)
			{
				var photon=cl.photonMap[photon_id];
				var sizeArray=photon.sizeArray;
				var positionX=photon.positionXArray;
				var positionY=photon.positionYArray;
				var positionZ=photon.positionZArray;
				var positionW=photon.positionWArray;
				var directionX=photon.directionXArray;
				var directionY=photon.directionYArray;
				var directionZ=photon.directionZArray;
				var colorR=photon.colorRArray;
				var colorG=photon.colorGArray;
				var colorB=photon.colorBArray;
				var positionXBuffer=photon.positionXBuffer;
				var positionYBuffer=photon.positionYBuffer;
				var positionZBuffer=photon.positionZBuffer;
				var positionWBuffer=photon.positionWBuffer;
				var directionXBuffer=photon.directionXBuffer;
				var directionYBuffer=photon.directionYBuffer;
				var directionZBuffer=photon.directionZBuffer;
				var normalXBuffer=photon.normalXBuffer;
				var normalYBuffer=photon.normalYBuffer;
				var normalZBuffer=photon.normalZBuffer;
				var colorRBuffer=photon.colorRBuffer;
				var colorGBuffer=photon.colorGBuffer;
				var colorBBuffer=photon.colorBBuffer;
				var redBuffer=photon.redBuffer;
				var greenBuffer=photon.greenBuffer;
				var blueBuffer=photon.blueBuffer;
				var randomBuffer=photon.randomBuffer;
				var args=
				[
					time,
					objectBoundingBox,
					positionXBuffer,
					positionYBuffer,
					positionZBuffer,
					positionWBuffer,
					directionXBuffer,
					directionYBuffer,
					directionZBuffer,
					normalXBuffer,
					normalYBuffer,
					normalZBuffer,
					colorRBuffer,
					colorGBuffer,
					colorBBuffer,
					redBuffer,
					greenBuffer,
					blueBuffer,
					randomBuffer,
					lightInfoArray,
					objectPrimaryIndicesBuffer,
					objectSecondaryIndicesBuffer,
					objectIndicesBuffer,
					objectVerticesBuffer,
					objectGridSizeArray,
					sizeArray
				];
				clSetKernelArgs(kernel1_id,args);
				clExecuteKernelProgram(kernel1_id);
				clReadKernelBuffer(kernel1_id,positionX,positionXBuffer,positionX.length);
				clReadKernelBuffer(kernel1_id,positionY,positionYBuffer,positionY.length);
				clReadKernelBuffer(kernel1_id,positionZ,positionZBuffer,positionZ.length);
				clReadKernelBuffer(kernel1_id,positionW,positionWBuffer,positionW.length);
				clReadKernelBuffer(kernel1_id,directionX,directionXBuffer,directionX.length);
				clReadKernelBuffer(kernel1_id,directionY,directionYBuffer,directionY.length);
				clReadKernelBuffer(kernel1_id,directionZ,directionZBuffer,directionZ.length);
				clReadKernelBuffer(kernel1_id,colorR,colorRBuffer,colorR.length);
				clReadKernelBuffer(kernel1_id,colorG,colorGBuffer,colorG.length);
				clReadKernelBuffer(kernel1_id,colorB,colorBBuffer,colorB.length);
				var photonInfo=
				{
					positionX:positionX,
					positionY:positionY,
					positionZ:positionZ,
					positionW:positionW,
					directionX:directionX,
					directionY:directionY,
					directionZ:directionZ,
					colorR:colorR,
					colorG:colorG,
					colorB:colorB
				};
				return photonInfo;
			}
			function clUpdateRandomBuffer()
			{
				var photon=cl.photonMap[photon_id];
				var randomArray=photon.randomArray;
				var randomBuffer=photon.randomBuffer;
				for(var i=0;i<randomArray.length;i++)
				{
					randomArray[i]=Math.random();
				}
				clWriteKernelBuffer(kernel1_id,randomArray,randomBuffer,randomBuffer.length);
			}
			var viewDistance=10.0,viewFocus=0.5;
			var viewDirection=new Vector3([0,0,-1]);
			var viewUpDirection=new Vector3([0,1,0]);
			var viewRightDirection=new Vector3([1,0,0]);
			var viewInfoArray=new Float32Array([0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0,0]);
			var eyeX=0,eyeY=0,eyeZ=viewDistance,translateMouseX=0,translateMouseY=0;
			var currentMouseX=0,currentMouseY=0,mouseIsDown=false;
			function clUpdateViewDirection()
			{
				var k=0.5;
				var rotUp=-k*translateMouseX;
				var rotRight=-k*translateMouseY;
				viewDirection.rotate(viewUpDirection,rotUp);
				viewRightDirection.rotate(viewUpDirection,rotUp);
				viewDirection.rotate(viewRightDirection,rotRight);
				viewUpDirection.rotate(viewRightDirection,rotRight);
				eyeX=-viewDirection.x()*viewDistance;
				eyeY=-viewDirection.y()*viewDistance;
				eyeZ=-viewDirection.z()*viewDistance;
			}
			function clUpdateViewInfo()
			{
				var eyePositionInfo=[eyeX,eyeY,eyeZ];
				var viewDirectionInfo=viewDirection.elements;
				var viewUpDirectionInfo=viewUpDirection.elements;
				var viewRightDirectionInfo=viewRightDirection.elements;
				viewInfoArray[0]=eyePositionInfo[0];
				viewInfoArray[1]=eyePositionInfo[1];
				viewInfoArray[2]=eyePositionInfo[2];
				viewInfoArray[3]=viewDirectionInfo[0];
				viewInfoArray[4]=viewDirectionInfo[1];
				viewInfoArray[5]=viewDirectionInfo[2];
				viewInfoArray[6]=viewUpDirectionInfo[0];
				viewInfoArray[7]=viewUpDirectionInfo[1];
				viewInfoArray[8]=viewUpDirectionInfo[2];
				viewInfoArray[9]=viewRightDirectionInfo[0];
				viewInfoArray[10]=viewRightDirectionInfo[1];
				viewInfoArray[11]=viewRightDirectionInfo[2];
				viewInfoArray[12]=cl.canvas[canvas_id].viewSize[0];
				viewInfoArray[13]=cl.canvas[canvas_id].viewSize[1];
				viewInfoArray[14]=viewDistance;
				viewInfoArray[15]=viewFocus;
			}
			var lightDistance=0.8;
			var lightColor=new Vector3([1,1,1]);
			var lightDirection=new Vector3([0.383,0.604,0.698]);
		//	var lightDirection=new Vector3([0,1,-0.2]);
			var lightUpDirection=new Vector3([0,1,0]);
			var lightRightDirection=new Vector3([0.876,0,-0.481]);
			var lightInfoArray=new Float32Array([0,0,1, 1.0,0.9,0.5, 0.8*10000, 0.2]);
			var translateUpDown=0,translateRightLeft=0,translateMouseZ=0;
			function clUpdateLightDirection()
			{
				var k=1.2;
				var rotUp=k*translateRightLeft;
				var rotRight=-k*translateUpDown;
				lightDirection.rotate(lightUpDirection,rotUp);
				lightRightDirection.rotate(lightUpDirection,rotUp);
				lightDirection.rotate(lightRightDirection,rotRight);
			}
			function clUpdateLightInfo()
			{
				var lightDirectionInfo=lightDirection.elements;
				lightInfoArray[0]=lightDirectionInfo[0]*lightDistance;
				lightInfoArray[1]=lightDirectionInfo[1]*lightDistance;
				lightInfoArray[2]=lightDirectionInfo[2]*lightDistance;
			}
			function clDisplayFunc()
			{
				var canvas=cl.canvas[canvas_id];
				var photon=cl.photonMap[photon_id];
				var sizeArray=canvas.sizeArray;
				var pixelBuffer=canvas.pixelBuffer;
				var positionXBuffer=canvas.positionXBuffer;
				var positionYBuffer=canvas.positionYBuffer;
				var positionZBuffer=canvas.positionZBuffer;
				var directionXBuffer=canvas.directionXBuffer;
				var directionYBuffer=canvas.directionYBuffer;
				var directionZBuffer=canvas.directionZBuffer;
				var renderInfo=new Float32Array([0,0,0]);
				var args=
				[
					renderInfo,
					objectBoundingBox,
					pixelBuffer,
					positionXBuffer,
					positionYBuffer,
					positionZBuffer,
					directionXBuffer,
					directionYBuffer,
					directionZBuffer,
					viewInfoArray,
					lightInfoArray,
					objectPrimaryIndicesBuffer,
					objectSecondaryIndicesBuffer,
					objectIndicesBuffer,
					objectVerticesBuffer,
					objectGridSizeArray,
					photon.positionXBuffer,
					photon.positionYBuffer,
					photon.positionZBuffer,
					photon.directionXBuffer,
					photon.directionYBuffer,
					photon.directionZBuffer,
					photonPrimaryIndicesBuffer,
					photonSecondaryIndicesBuffer,
					photonInfoBuffer,
					photonGridSizeArray,
					sizeArray
				];
				var times=1;
				for(var i=0;i<times;i++)
				{
					renderInfo[0]=i;
					clSetKernelArgs(kernel_id,args);
					clExecuteKernelProgram(kernel_id);
				}
				clReadKernelBuffer(kernel_id,canvas.image.data,pixelBuffer,pixelBuffer.length);
				canvas.context.putImageData(canvas.image,0,0);
			}
			function clConcentricMap(x,y)
			{
				if(x==0&&y==0)return [0,0];
				var r=0,p=0,PI=3.1415926;
				if(x*x>y*y){r=x;p=y/x*PI/4;}
				else{r=y;p=PI/2-x/y*PI/4;}
				return [r*Math.cos(p),r*Math.sin(p)];
			}
			function clResizeCanvas(id,scale)
			{
				var canvas=cl.canvas[id],k=scale;
				var width=canvas.width,height=canvas.height;
				var width_k=width*k,height_k=height*k;
				canvas.element.setAttribute("width",width_k);
				canvas.element.setAttribute("height",height_k);
				var image=canvas.resizedImage;
				if(image==null)
				{
					image=canvas.context.createImageData(width_k,height_k);
					canvas.resizedImage=image;
				}
				for(var i=0;i<height_k;i++)
				{
					for(var j=0;j<width_k;j++)
					{
						image.data[(i*width_k+j)*4+0]=clInterpolatePixel(canvas.image,width,i/k,j/k,0);
						image.data[(i*width_k+j)*4+1]=clInterpolatePixel(canvas.image,width,i/k,j/k,1);
						image.data[(i*width_k+j)*4+2]=clInterpolatePixel(canvas.image,width,i/k,j/k,2);
						image.data[(i*width_k+j)*4+3]=clInterpolatePixel(canvas.image,width,i/k,j/k,3);
					}
				}
				canvas.context.putImageData(image,0,0);
			}
			function clInterpolatePixel(image,width,i,j,k)
			{
				var i0=Math.floor(i),i1=i0+1,u=i-i0;
				var j0=Math.floor(j),j1=j0+1,v=j-j0;
				var p00=image.data[(i0*width+j0)*4+k];
				var p01=image.data[(i0*width+j1)*4+k];
				var p11=image.data[(i1*width+j1)*4+k];
				var p10=image.data[(i1*width+j0)*4+k];
				var p0V=(1.0-v)*p00+v*p01;
				var p1V=(1.0-v)*p10+v*p11;
				return (1.0-u)*p0V+u*p1V;
			}
			function clGetKernelSource(id)
			{
				var kernelSource=document.getElementById(id);
				if(kernelSource===null)return null;
				if(kernelSource.type!="x-kernel")return null;
				return kernelSource.firstChild.textContent;
			}
			function clSetKernelArgs(id,args)
			{
				var kernel=cl.kernels[id];
				kernel.args=args;
				for(var i=0;i<args.length;i++)
				{
					kernel.setArg(i,args[i]);
				}
				kernel.workDim=args[args.length-1].length;
				kernel.localWorkSize=clGetLocalWorkSize(id,kernel.workDim);
				kernel.globalWorkSize=clGetGlobalWorkSize(id,kernel.localWorkSize);
			}
			function clExecuteKernelProgram(id)
			{
				var kernel=cl.kernels[id];
				var queue=kernel.commandQueue;
				var workDim=kernel.workDim,globalWorkOffset=kernel.globalWorkOffset;
				var globalWorkSize=kernel.globalWorkSize,localWorkSize=kernel.localWorkSize;
				queue.enqueueNDRangeKernel(kernel,workDim,globalWorkOffset,globalWorkSize,localWorkSize);
			}
			function clReadKernelBuffer(id,outputData,kernelBuffer,length)
			{
				var queue=cl.kernels[id].commandQueue;
				queue.enqueueReadBuffer(kernelBuffer,true,0,length,outputData);
			}
			function clWriteKernelBuffer(id,inputData,kernelBuffer,length)
			{
				var queue=cl.kernels[id].commandQueue;
				queue.enqueueWriteBuffer(kernelBuffer,true,0,length,inputData);
			}
			function clGetLocalWorkSize(id,workDim)
			{	
				var GROUP_SIZE=webcl.KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE;
				var groupSize=cl.kernels[id].getWorkGroupInfo(cl.devices[0],GROUP_SIZE);
				switch(workDim)
				{
					case 1: return [groupSize];
					case 2: return dim2(groupSize);
					case 3: return dim3(groupSize);
				}
			}
			function clGetGlobalWorkSize(id,localWorkSize)
			{
				var globalWorkSize=[];
				var args=cl.kernels[id].args;
				var workSize=args[args.length-1];
				for(var i=0;i<localWorkSize.length;i++)
				{
					var k=Math.ceil(workSize[i]/localWorkSize[i]);
					globalWorkSize[i]=k*localWorkSize[i];
				}
				return globalWorkSize;
			}
			function dim2(size)
			{
				var xSize=pow2(Math.floor(Math.sqrt(size)));
				return [xSize, Math.floor(size/xSize)];
			}
			function dim3(size)
			{
				var xSize=pow2(Math.floor(Math.pow(size,1/3)));
				var ySize=pow2(Math.floor(Math.sqrt(size/xSize)));
				return [xSize, ySize, Math.floor(size/(xSize*ySize))];
			}
			function pow2(x){return isPowerOfTwo(x)?x:nextHighestPowerOfTwo(x);}
			function isPowerOfTwo(x){return (x&(x-1))==0;}
			function nextHighestPowerOfTwo(x)
			{
				--x;
				for(var i=1;i<32;i<<= 1)x=x|x>>i;
				return x+1;
			}
			function clAddEventListener()
			{
				cl.canvas[canvas_id].onmousemove=mouseDragged;
				cl.canvas[canvas_id].onmousedown=mouseDown;
				cl.canvas[canvas_id].onmouseup=mouseUp;
				document.onkeydown=keyPressed;
			}
			function mouseDragged(e)
			{
				if(!mouseIsDown)return;
				var x=e.clientX,y=e.clientY;
				translateMouseX=x-currentMouseX;
				translateMouseY=y-currentMouseY;
				currentMouseX=x;
				currentMouseY=y;
				clUpdateViewDirection();
				clUpdateViewInfo();
				clDisplayFunc();
			}
			function mouseDown(e)
			{
				var x=e.clientX,y=e.clientY;
				currentMouseX=x;
				currentMouseY=y;
				mouseIsDown=true;
			}
			function mouseUp(e)
			{
				mouseIsDown=false;
			}
			var KEY_LEFT=37,KEY_UP=38,KEY_RIGHT=39,KEY_DOWN=40;
			function keyPressed(e)
			{
				if(e.keyCode==KEY_LEFT)
				{
					translateRightLeft=-1;
					clUpdateLightDirection();
					clUpdateLightInfo();
					clDisplayFunc();
				}
				else if(e.keyCode==KEY_RIGHT)
				{
					translateRightLeft=1;
					clUpdateLightDirection();
					clUpdateLightInfo();
					clDisplayFunc();
				}
				else if(e.keyCode==KEY_UP)
				{
					translateUpDown=1;
					clUpdateLightDirection();
					clUpdateLightInfo();
					clDisplayFunc();
				}
				else if(e.keyCode==KEY_DOWN)
				{
					translateUpDown=-1;
					clUpdateLightDirection();
					clUpdateLightInfo();
					clDisplayFunc();
				}
				translateRightLeft=0;
				translateUpDown=0;
			}
		</script>
	</head>
	<body onload="main()">
		<center><div id="webcl-canvas"></div></center>
	</body>
</html>
